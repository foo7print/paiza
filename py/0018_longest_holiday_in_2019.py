
# import datetime
# print(datetime.date(2019, 1, 1).weekday())
# => 1
# 0 : 月曜日, 1 : 火曜日, 2 : 水曜日, 3 : 木曜日, 4 : 金曜日, 5 : 土曜日, 6 : 日曜日
# 2019年は火曜日から始まる
youbi = ["火", "水", "木", "金", "土", "日", "月"]
donichi = ["土", "日"]

# 2019年の内閣府の定める国民の祝日・休日
data = [
    "2019/1/1",
    "2019/1/14",
    "2019/2/11",
    "2019/3/21",
    "2019/4/29",
    "2019/4/30",
    "2019/5/1",
    "2019/5/2",
    "2019/5/3",
    "2019/5/4",
    "2019/5/5",
    "2019/5/6",
    "2019/7/15",
    "2019/8/11",
    "2019/8/12",
    "2019/9/16",
    "2019/9/23",
    "2019/10/14",
    "2019/10/22",
    "2019/11/3",
    "2019/11/4",
    "2019/11/23",
]

# 月の日数
# 1月：31
# 2月：28
# 3月：31
# 4月：30
# 5月：31
# 6月：30
# 7月：31
# 8月：31
# 9月：30
# 10月：31
# 11月：30
# 12月：31
n = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# 月の値
m = 1
# 日の値
d = 1
# 出力する値
ans = 0
# 連休日数
count = 0

for i in range(365):
    # 土日の場合
    if youbi[i % 7] in donichi:
        count += 1
    # 2019年の内閣府の定める国民の祝日・休日に合致した場合
    elif f"2019/{m}/{d}" in data:
        count += 1
    else:
        # 今月最長の連休日数と前月までの最高の連休を比較し、大きい方の値を格納
        ans = max(ans, count)
        # 初期化
        count = 0
    
    # その月の最終日であるかを判定
    if n[m - 1] == d:
        # 初期化
        d = 1
        # 次の月へインクリメント
        m += 1
    else:
        # 日付をインクリメント
        d += 1

print(ans)

